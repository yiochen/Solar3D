<!DOCTYPE html>
<html>

<head>
    <title>Testing threejs</title>
    <!--    <script type="text/javascript" scr="three.js"></script>-->
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        
        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/dat.gui.min.js"></script>
    <script type="text/javascript" src="libs/stats.min.js"></script>
    <script type="text/javascript" src="libs/OrbitControls.js"></script>
    <script type="text/javascript" src="libs/Projector.js"></script>
    <script type="text/javascript">
        var scene;
        var camera;
        var stats;
        var renderer;
        var controls;
        var projector;
        var sun;
        var counter = 0;
        var CONST = {
            minRadius: 2,
            maxRadius: 10,
            minDistance: 50,
            maxDistance: 150,
            minVel: 3,
            maxVel: 6,
            primaryColor: 0x00AAFF,
            primaryColor2: 0x284BD7,
            accentColor: 0xff98cb,
            boxSize: 10000,
            accel: 0.5,
            velDeg: 1,
        };
        var stars = [];
        window.onload = init;

        function init() {
            scene = new THREE.Scene();
            //view_angle, ratio(width/height), near, far
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
            scene.add(camera);
            camera.position.set(0, 100, 300);
            camera.lookAt(scene.position);
            projector = new THREE.Projector();
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1.0);
            renderer.shadowMap.enabled = true;
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.maxPolarAngle = Math.PI / 2;
            controls.maxDistance = CONST.boxSize / 2;
            createObjects();

            //create_geometry();
            create_stats();
            document.body.appendChild(renderer.domElement);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            render();
        }

        function create_stats() {
            stats = new Stats();
            stats.setMode(0);
            stats.domElement.style.position = "absolute";
            stats.domElement.style.left = "0";
            stats.domElement.style.top = "0";
            document.body.appendChild(stats.domElement);
            console.log("created stats");

        }

        function rndBtw(x, y) {
            return Math.random() * (y - x) + x;
        }

        function createRandomStar() {
            var distance;
            var radius
            return createStar(
                radius = rndBtw(CONST.minRadius, CONST.maxRadius),
                distance = rndBtw(CONST.minDistance, CONST.maxDistance),
                Math.random() * Math.PI * 2,
                rndBtw(CONST.minVel, CONST.maxVel) / distance / radius);
        }

        function createObjects() {
            createSky();
            createFloor();
            createSun();
            createStar(4, 50, 3, 0.01).prop.func.push(revolve, sinBounce, ring);

            createStar(6, 70, 4, 0.012).prop.func.push(revolve, disco);
            for (var i = 2; i < 10; i++) {
                createRandomStar().prop.func.push(revolve);
            }
            createLight();
            createFog();
        }

        function createFog() {
            var fog = new THREE.FogExp2(CONST.primaryColor, 0.001);
            scene.fog = fog;
        }

        function createLight() {
            var hemiLight = new THREE.HemisphereLight(CONST.primaryColor, CONST.primaryColor2, 1);
            scene.add(hemiLight);
            var sunLight = new THREE.PointLight(CONST.accentColor, 1, 1000);
            scene.add(sunLight);
            //var dirLight = new THREE.DirectionalLight(CONST.primaryColor, 0.5);
            //dirLight.position.set(0, 1, 0);
            //scene.add(dirLight);

            //var dirLight2 = new THREE.DirectionalLight(CONST.primaryColor2, 0.5);
            //dirLight2.position.set(0, -1, 0);
            //scene.add(dirLight2);
            var spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(0, 1000, 0);
            spotLight.castShadow = true;
            spotLight.onlyShadow = true;
            spotLight.intensity = 0.5;
            //            spotLight.shadowMapWidth = 1024; // spotLight.shadowMapHeight = 1024;
            spotLight.exponent = 9.42;
            spotLight.angle = 1.234;
            scene.add(spotLight);

        }

        function createSky() {
            var skyboxGeo = new THREE.BoxGeometry(CONST.boxSize, CONST.boxSize, CONST.boxSize);
            var skyboxMat = new THREE.MeshBasicMaterial({
                color: CONST.primaryColor,
                side: THREE.BackSide,
            });
            var skyboxMesh = new THREE.Mesh(skyboxGeo, skyboxMat);

            scene.add(skyboxMesh);
        }

        function createFloor() {
            var floorGeo = new THREE.PlaneGeometry(CONST.boxSize, CONST.boxSize);
            var floorMat = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                side: THREE.DoubleSide
            });

            var floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = 0.5 * Math.PI;
            floor.position.y = -CONST.maxRadius - 3;
            floor.receiveShadow = true;
            scene.add(floor);

        }

        function addGlow() {

        }

        function createSun() {
            sun = createStar(10, 0);
            sun.material = new THREE.MeshBasicMaterial({
                map: new THREE.ImageUtils.loadTexture('assets/sunmap.jpg')
            });
            sun.castShadow = false;
            //sun.prop.stall = true;
            sun.prop.func.push(rotate, jump);
            var spriteMaterial = new THREE.SpriteMaterial({
                map: new THREE.ImageUtils.loadTexture('assets/glow.png'),
                color: 0xFFCD00,
                transparent: false,
                blending: THREE.AdditiveBlending,
            });

            var sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(sun.prop.radius * 4, sun.prop.radius * 4, 1.0);
            sun.add(sprite);

        }

        function createStar(radius, distance, angle, angularVel) {
            var starGeo = new THREE.SphereGeometry(radius, 30, 30);
            var starMat = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0x000033,
            });
            var starMesh = new THREE.Mesh(starGeo, starMat);

            var prop = {
                radius: radius,
                distance: distance,
                angle: (typeof (angle) !== 'undefined') ? angle : 0,
                angularVel: (typeof (angularVel) !== 'undefined') ? angularVel : 0,
                stall: false,
                func: [],
            };
            starMesh.castShadow = true;
            starMesh.prop = prop;
            stars.push(starMesh);
            scene.add(starMesh);
            return starMesh;
        }

        function onDocumentMouseDown(event) {
            console.log("click");
            var mouse = {};
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
            vector.unproject(camera);
            var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
            var intersects = ray.intersectObjects([sun]);
            if (intersects.length > 0) {
                console.log("Hit!!@" + toString(intersects[0].point));
                sun.prop.speed = 5;
            }
        }
        //////////////////////////////////////////////////////////
        //------------------------------------------------------//
        //------------------------------------------------------//
        //-----------------------Actions------------------------//
        //------------------------------------------------------//
        //------------------------------------------------------//
        //////////////////////////////////////////////////////////



        function revolve(star) {
            var prop = star.prop;
            if (!prop) {
                return;
            }
            star.prop.angle += star.prop.angularVel;
            var x = prop.distance * Math.sin(prop.angle);
            var z = prop.distance * Math.cos(prop.angle);
            star.position.set(x, 0, z);
        }

        function rotate(star) {
            star.rotation.y += 0.1;
        }

        function updateStar(star) {
            for (var func of star.prop.func) {
                func(star);
            }
        }

        function jump(star) {
            if (star.prop.speed == null) {
                return;
            } else {
                var pos = star.position.y;
                pos += star.prop.speed;

                if (pos < 0 && star.prop.speed > 0) {
                    pos = 0;
                    star.prop.speed = null;
                } else {
                    pos += star.prop.speed;
                    if (pos < 0 && star.prop.speed < 0) {
                        pos = 0;
                        star.prop.speed = -star.prop.speed - CONST.velDeg;
                    } else {
                        star.prop.speed -= CONST.accel;
                    }


                }
                star.position.set(star.position.x, pos, star.position.z);
            }
        }

        function sinBounce(star) {
            star.position.set(star.position.x, 5 * Math.sin(counter / 10), star.position.z);
        }

        function ring(star) {
            if (star.prop.ring) {
                //star.prop.ring.rotation.x += 0.05;
                star.prop.ring.rotation.y += 0.05;
                //star.prop.ring.rotation.z += 0.05
            } else {
                var material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                });
                var radius = star.prop.radius * 1.5;
                var circleGeometry = new THREE.CircleGeometry(radius, 30);
                var circle = new THREE.Mesh(circleGeometry, material);
                star.add(circle);
                star.prop.ring = circle;
            }
        }

        function disco(star) {
            star.material.emissive = new THREE.Color(Math.random() * 0xFFFFFF);
        }

        function render() {
            counter++;
            stats.update();
            controls.update();
            for (var star of stars)
                if (!star.prop.stall) updateStar(star);
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>